# TD : Terminaison et correction

## Algos impératifs

1. Preuves de terminaisons

| Algorithme | Termine ? |                            Preuve                            |
| :--------: | :-------: | :----------------------------------------------------------: |
|     1      |    oui    | Variant : -i<br />1) Avant la boucle, i est négatif de par les préconditions donc -i est positif.<br />2) Tant que la boucle continue, i <= -1 donc -i est positif.<br />3) En notant i' la valeur de i à la fin d'une itération, on a i' = i+1. Donc -i' = -i-1 < -i. Ainsi le variant décroît strictement d'une itération à une autre.<br />ccl) La boucle admet un variant et toutes les autres instructions terminent trivialement donc l'algorithme termine. |
|     2      |    non    | Pour n = 1 et m = 2, n devient -1 à la première itération et continuera de décroître par la suite donc ne sera jamais égal à 0 (la condition de sortie de la boucle ne sera jamais atteinte). |
|     3      |    non    | Pour n > TAILLE(T), n va continuellement croître et ne sera donc jamais égal à TAILLE(T), la condition d'arrêt de la boucle ne sera jamais atteinte. |
|     4      |    oui    | Variant : a+b.<br />1) Avant la boucle, a+b est positif car a et b sont deux entiers naturels (précondition).<br />2) Tant que la boucle continue, a > 0 et b > 0 donc a+b positif.<br />3) En notant a' et b' les valeurs respectives de a et b à la fin d'une itération, on a :<br />- soit (dans le "si") a' = a+1 et b' = b-3 donc a'+b' = a+b-2 < a+b.<br />- soit (dans le "sinon") a' = a-2 et b' = b+1 donc a'+b' = a+b-1 < a+b.<br />Ainsi le variant décroît strictement.<br />ccl) La boucle admet un variant et toutes les autres instructions terminent trivialement donc l'algorithme termine. |
|     5      |    non    | Prenons a et b entiers strictement positifs quelconques, et c un entier strictement négatif quelconque. a et b vont rester strictement positifs puisqu'on leur soustrait un entier strictement négatif (donc on leur ajoute un entier strictement positif) donc le cas de sortie de boucle ne sera jamais atteint. |
|     6      |    non    | Il suffit de prendre un tableau T qui ne contiennent pas l'entier e. |
|     7      |    oui    | Variant : x+y.<br />1) Avant la boucle, x+y est positif car x et y sont deux entiers naturels (précondition).<br />2) Tant que la boucle continue, $`x \geq 0`$ et $`y \geq 0`$ donc x+y positif.<br />3) En notant x' et y' les valeurs respectives de x et y à la fin d'une itération, on a :<br />- soit (dans le "si") x' = x et y' = y-1 donc x'+y' = x+y-1 < y+x.<br />- soit (dans le "sinon") x' = 0 et y' < x donc x'+y' < x. De plus y = 0 (sinon on serait entré dans le "si") donc x'+y' < x + y.<br />Ainsi le variant décroît strictement.<br />ccl) La boucle admet un variant et toutes les autres instructions terminent trivialement donc l'algorithme termine. |

2. 3. 4. 5. 6. 7. Preuves de corrections totales.

Ayant rédigé plusieurs preuves de terminaison dans la première question, je me permets ici de donner les variants sans les justifier. N'hésitez pas me poser la question si vous avez un problème lors de la rédaction d'un des trois points de la preuve (positif avant la boucle, positif tant que la condition de boucle est vraie, strictement décroissant d'une itération à l'autre). Toutes les autres instructions des algorithmes terminent trivialement, les variants de boucle suffisent donc à justifier la terminaison des algorithmes.

|      Algorithme       |                Terminaison                |                          Correction                          |
| :-------------------: | :---------------------------------------: | :----------------------------------------------------------: |
|        NB_OCCS        |         Variant : TAILLE(T) - i.          | Inv(i, res) : $`res = \displaystyle\sum_{\substack{0 \leqslant j < i \\ T_j = e}} 1`$.<br />1) Avant la boucle i = 0 donc la somme est nulle, or res = 0 donc l'invariant est vrai.<br />2) Supposons l'invariant vrai en entrée d'une itération de la boucle, et montrons qu'il est toujours vrai en sortie de cette itération.<br />Notons i' et res' les valeurs respectives de i et res en fin d'une itération.<br />On a i' = i + 1.<br />Distinguons les cas.<br />Si $`T_i = v`$, res' = res + 1 =  $`\displaystyle\left(\sum_{\substack{0 \leqslant j < i \\ T_j = e}} 1\right) + 1`$ car on a supposé l'invariant vrai au début de l'itération.<br/>Donc res' = $`\sum_{\substack{0 \leqslant j < i+1 \\ T_j = e}} 1 = \sum_{\substack{0 \leqslant j < i' \\ T_j = e}} 1`$<br /><br />Sinon, res' = res = $`\sum_{\substack{0 \leqslant j < i \\ T_j = e}} 1`$ car on a supposé l'invariant vrai au début de l'itération.<br />Donc res' = $`\sum_{\substack{0 \leqslant j < i+1 \\ T_j = e}} 1 = \sum_{\substack{0 \leqslant j < i' \\ T_j = e}} 1`$car $`T_i \neq v`$<br/>On a donc bien Inv(i', res') vrai.<br/>3) En sortie de boucle, i = TAILLE(T) ainsi l'invariant nous donne $`res = \displaystyle\sum_{\substack{0 \leqslant j < \texttt{TAILLE(T)} \\ T_j = e}} 1`$. Ainsi res contient le nombre d'indices $j$ du tableau T tels que $`T_j = e`$ i.e. le nombre d'occurrences de e dans T.<br />ccl) L'algorithme renvoie res qui d'après l'invariant est égal au nombre d'occurrences de e dans T, et toutes les autres instructions sont trivialement correctes ainsi l'algorithme est correct. |
| MYSTERE (parité de n) |               Variant : n.                | Inv(n) : $`n \equiv N \pmod 2`$<br />1) Avant la boucle n = N donc l'invariant est trivialement vrai.<br />2) Supposons l'invariant vrai en entrée d'une itération de la boucle, et montrons qu'il est toujours vrai en sortie de cette itération.<br />Notons n' la valeur de n à la fin d'une itération. On a n' = n - 2, or $`n \equiv n-2 \pmod 2`$<br />Comme on a supposé l'invariant vrai au début de l'itération, on a $`N \equiv n \equiv n-2 \equiv n' \pmod 2`$<br />On a donc bien Inv(n') vrai.<br />3) En sortie de la boucle, soit n = 0 ainsi d'après l'invariant $`N \equiv 0 \pmod 2`$, soit n = 1 ainsi l'invariant donne $`N \equiv 1 \pmod 2`$<br /> ccl) L'algorithme renvoie VRAI ssi n = 0, ce qui d'après l'invariant signifie qu'on renvoie VRAI ssi  $`N \equiv 0 \pmod 2`$ (donc ssi N est pair). |
|          LOG          |             Variant : n - p.              | $`Inv(k, p) : p = 2^k, 2^{k-1} < n`$.<br />1) Avant la boucle k = 0, p = 1 or $`1=2^0 \text{ et } n \geq 1 > 2^{-1}`$ (précondition pour n), donc l'invariant est vrai.<br />2) Supposons l'invariant vrai en entrée d'une itération de la boucle, et montrons qu'il est toujours vrai en sortie de cette itération.<br />Notons k' et p' les valeurs respectives de k et p en fin d'une itération.<br />On a : k' = k+1 et p' = 2p, donc comme on a supposé l'invariant vrai au début de l'itération : <br />- $`p' = 2 \times p = 2 \times 2^k = 2^{k+1} = 2^{k'}`$<br />- n > p (condition de boucle) donc $`n > 2^k = 2^{k'-1}`$.<br />Ainsi Inv(k', p') vrai.<br />3) En sortie de boucle, $`p \geq n`$ donc l'invariant nous donne $`2^k \geq n \text{ et } 2^{k-1} < n`$. Ainsi k est le plus petit entier tel que $`2^k \leq n`$.<br />ccl) L'algorithme renvoie k qui est le bon résultat d'après l'invariant et toutes les autres instructions sont trivialement correctes ainsi l'algorithme est correct. |
|        MAX_TAB        |         Variant : TAILLE(T) - i.          | Invariant : maxi = $`\max\limits_{0 \leqslant j < i} T_j`$.<br />1) Avant la boucle i = 1 et maxi = $`T_0 = \max\limits_{0 \leqslant j < 1} T_j`$.<br />2) Supposons l'invariant vrai en entrée d'une itération de la boucle, et montrons qu'il est toujours vrai en sortie de cette itération.<br />Notons i' et maxi' les valeurs respectives de i et maxi en fin d'une itération.<br />i' = i + 1 et maxi' = MAX(maxi, $`T_i`$)<br />Comme on a supposé l'invariant vrai au début de l'itération,<br />maxi' = $`\max(\max\limits_{0 \leqslant j < i} T_j, T_i) = \max\limits_{0 \leqslant j < i+1} T_j = \max\limits_{0 \leqslant j < i'} T_j`$<br />L'invariant est vrai en fin d'itération.<br />3) En sortie de boucle, i = TAILLE(T) donc l'invariant nous donne maxi = $`\max\limits_{0 \leqslant j < \texttt{TAILLE(T)}} T_j`$, autrement dit maxi est la valeur maximale présente dans le tableau T.<br />ccl) L'algorithme renvoie maxi qui est le bon résultat d'après l'invariant et toutes les autres instructions sont trivialement correctes ainsi l'algorithme est correct. |
|         FIBO          |             Variant : n - i.              | Je note "ad" la variable avant_dernier et "d" la variable dernier.<br />Inv(i, ad, d) : $`ad = F_i, d = F_{i+1}`$.<br />1) Avant la boucle, i = 0, ad = 0, d = 1. Or $`F_0 = 0 \text{ et } F_1 = 1`$. L'invariant est donc vrai avant la boucle.<br />2) Supposons l'invariant vrai en entrée d'une itération de la boucle, et montrons qu'il est toujours vrai en sortie de cette itération.<br />Notons i', ad', d' les valeurs respectives de i, ad et d à fin d'une itération. On a :<br />i' = i+1 ; ad' = d ; d' = ad + d<br />Comme on a supposé l'invariant vrai au début de l'itération, on a ainsi :<br />ad' = $`F_{i+1} = F_{i'}`$ et d' = $`F_i + F_{i+1} = F_{i+2} = F_{i'+1}`$.<br />On a donc bien Inv(i', ad', d') vrai.<br />3) En sortie de boucle, i = n. Donc l'invariant nous donne $`ad = F_n, d = F_{n+1}`$.<br />ccl) L'algorithme renvoie ad qui d'après l'invariant de boucle est le `n`-ième terme de la suite de Fibonacci, et les autres instructions sont correctes trivialement, ainsi l'algorithme est correct (totalement puisqu'il termine). |
|       DISJOINTS       | Variant : taille(U) + taille(V) - iu - iv | $`Inv(iu, iv) : U \cap V_{0 \rightarrow iv-1} = \emptyset, V \cap U_{0 \rightarrow iu-1} = \emptyset`$.<br />Il faut montrer les 3 points habituels pour cet invariant (vrai avant la boucle, si vrai en entrée d'une itération alors vrai en fin de l'itération, vrai en sortie de la boucle), n'hésitez pas à venir me voir si la rédaction vous pose problème. |



## Algos fonctionnels

8. Preuves de terminaisons

| Algorithme | Termine ? |                            Preuve                            |
| :--------: | :-------: | :----------------------------------------------------------: |
|     1      |    non    | Pour n = 1 et m = 2, n devient -1 au premier appel et continuera de décroître par la suite donc ne sera jamais égal à 0 (le cas de base ne sera jamais atteint). |
|     2      |    oui    | Montrons par récurrence H(n) : F(x, y) termine avec n = x+y.<br />Initialisation. Pour n = 0, on a x = y = 0 (car ce sont des entiers naturels). On est donc dans le cas de base de la fonction qui termine trivialement.<br />Hérédité. Supposons H(n-1) vraie pour un certain n >= 1. Montrons H(n) : F(x, y) termine avec n = x+y.<br />Si n=x+y avec n >=1 alors x+y>0, on est donc dans un des deux cas récursifs.<br />Le premier cas récursif fait un appel sur x-1 et y, or x-1+y = n-1. Cet appel termine donc par hypothèse de récurrence.<br />Le second cas récursif fait un appel sur x et y-1, or x+y-1=n-1. Cet appel termine donc par hypothèse de récurrence.<br />Les deux appels récursifs terminent et les autres instructions terminent trivialement donc H(n) vraie.<br />ccl) F(x, y) termine pour toutes entrées x et y respectant les préconditions. |
|     3      |    non    | Prenons x = 0 et y = 1, le premier appel lance F(5, -7) dans le SINON qui va alors lancer des appels récursifs à l'infini en entrant dans le deuxième SI (x va augmenter car on lui ajoute une quantité négative et y va diminuer car on le multiplie par 2). |
|     4      |    oui    | On suppose que "tete" et "queue" terminent.<br />Montrons par récurrence forte H(n) : F(L) termine pour n = TAILLE(L).<br />Initialisation. Pour n = 0, L est vide donc on est dans un cas de base qui termine trivialement. Pour n = 1, L possède 1 élément donc sa queue est vide, on est également dans un cas de base qui termine trivialement.<br />Hérédité. Supposons H(0), H(1), ..., H(n-1) vraie pour n > 1. Montrons H(n).<br /> n > 1 donc L au moins 2 éléments. Si les deux premiers éléments sont différents la fonction termine trivialement (cas de base). Sinon, la fonction effectue un appel récursif sur queue(queue(L)), qui est donc une liste de taille n - 2. Cet appel termine par hypothèse de récurrence, et les autres instructions terminent trivialement donc H(n) vraie.<br />ccl) F(L) termine pour toute liste L passée en entrée. |
|     5      |    non    | Il suffit de prendre a et b entiers positifs pairs et différents. |
|     6      |    non    | Prenons a négatif et b strictement positif. Les appels récursifs se font tous deux sur a-1 donc la parité de a alterne d'un appel à l'autre. Ainsi b va augmenter et diminuer de 1 alternativement d'un appel à l'autre, et aucun des deux cas de base ne sera atteint. |
|     7      |    non    | Prenons x et y strictement négatifs. On entre alors dans le dernier "sinon" et si l'entier tmp tiré est négatif à chaque fois, on appelle la fonction sur deux entiers plus petits donc on n'atteindra jamais le cas de base. |

9. Preuves de corrections totales.

    Les preuves se font par récurrence. On peut montrer à la fois terminaison et correction en une seule preuve. Des exemples de rédaction ont été faites en cours, je ne rédige donc pas les preuves ici. Mais n'hésitez pas à venir me voir si vous n'y parvenez pas.

    1. Il faut montrer la propriété H(n) : x\_puissance\_n(x, n), avec x entier naturel quelconque, termine et renvoie $`x^n`$.
    2. Il faut montrer la propriété H(n) : est_pair(n) termine et renvoie vrai si n est pair, faux sinon. La preuve se fera par récurrence forte (à cause du cas récursif sur n - 2), l'initialisation pour H(0) et H(1).
    3. Il faut montrer la propriété H(n) : somme_liste(L) avec L de taille n, termine et renvoie la somme de tous les éléments de la liste L.
    4. Il faut montrer la propriété H(n) : minimum_liste(L) avec L de taille n, termine et renvoie le plus petit élément de la liste L.
    5. Il faut montrer la propriété H(n) : taille_l1_inferieure_taille_l2($`l_1, l_2`$) avec n = TAILLE($`l_1`$) + TAILLE($`l_2`$), termine et renvoie VRAI ssi TAILLE$(`l_1) \leq`$  TAILLE$`(l_2)`$. La preuve se fera par récurrence forte.
    6. Il faut montrer la propriété H(n) : disjoints ($`l_1, l_2`$) avec n = TAILLE($`l_1`$) + TAILLE($`l_2`$), termine et renvoie VRAI ssi $`l_1`$ et $`l_2`$ n'ont aucun élément en commun.


10. Les algorithmes de cette question font partie de ceux pour lesquels vous devez être capables très rapidement de les ré-écrire et de les analyser. Je vous conseille *vivement* de faire une fiche pour chacun de ces algorithmes ! Si nécessaire, répartissez-vous les algos avec un (ou plusieurs) camarade(s). N'hésitez pas à me montrer vos fiches si vous souhaitez que je les vérifie.

---

Par *Justine BENOUWT*

Sous licence [*CC BY-NC-SA*](https://creativecommons.org/licenses/by-nc-sa/4.0/)

![CC BY-NC-SA](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)
